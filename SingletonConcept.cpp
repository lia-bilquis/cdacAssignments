#include <iostream>using namespace std;//Singleton classclass Singleton{    //Ctor and Dtor made private for manually controlling object creations process    Singleton()    {        cout << "Singleton::Singleton()" << endl;    }    ~Singleton()    {        cout << "Singleton::~Singleton()" << endl;    }    static Singleton *head;protected:    static Singleton *Create()    {        //if head is NULL it means that Singleton object is not created        if (head == NULL)        {            head = new Singleton();        }        return head;    }    static void Release()    {        //release Singleton from heap and reset head to NULL        delete head;        head = NULL;    }public:    //public function    void fun()    {        cout << "Singleton::fun()" << endl;    }    //Smart class made as friend for restricting Singleton creation only to Smart class ;)    friend class Smart;};Singleton *Singleton::head = NULL;//Our basic Smart Pointer class; Smart Pointer is class which acts as pointer to a another class and manages memoryclass Smart{    Singleton *Sptr;    static int count;    //We should restrict Smart class to be made on heap :)    static void *operator new(size_t size)    {        return 0;    }    static void *operator new[](size_t size)    {        return 0;    }    static void operator delete(void *)    {    }    static void operator delete[](void *)    {    }public:    Smart() : Sptr(Singleton::Create())    {        count++;    }    Singleton *operator->()    {        return Sptr;    }    ~Smart()    {        count--;        if (0 == count) //we should release Singleton class only on last Destructor class        {            Singleton::Release();        }    }};int Smart::count = 0;int main(){    Smart s1;    Smart s2;    Smart s3;    Smart s5;    s1->fun();    return 0;}